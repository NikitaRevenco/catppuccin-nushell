---
whiskers:
  version: 2.5.1
  matrix:
    - flavor
  filename: "themes/catppuccin_{{ flavor.identifier }}.nu"
---
let palette = {
{%- for identifier, color in flavor.colors %}
  {{ identifier }}: "#{{ color.hex }}"
{%-endfor %}
}

$env.config.color_config = {
{#

  for instance, color of the border of each table

  #}  separator: { fg: $theme.surface2 attr: b }
  leading_trailing_space_bg: { attr: n }
  header: $theme.text
  empty: { bg: $theme.green fg: $theme.base }
  bool: $theme.peach
  int: $theme.peach
  filesize: {|fsize|
      if $fsize < 10kb {
          $theme.green
      } else if $fsize < 1mb {
          $theme.yellow
      } else if $fsize < 10mb {
          $theme.peach
      } else if $fsize < 1gb {
          $theme.maroon
      } else if $fsize > 1gb {
          $theme.red
      }
  }
  duration: $theme.text
  date: {|| (date now) - $in |
    if $in < 1wk {
        $theme.green
    } else if $in < 4wk {
        $theme.yellow
    } else if $in < 12wk {
        $theme.peach
    } else if $in < 52wk {
        $theme.maroon
    } else if $in > 52wk {
        $theme.red
    }
  }
  background: $theme.base
  foreground: $theme.text
  range: $theme.text
  float: $theme.text
  string: $theme.text
  nothing: $theme.text
  binary: $theme.text
  cell-path: $theme.text
  row_index: $theme.subtext1
  record: $theme.text
  list: $theme.text
  hints: $theme.surface2
  search_result: { bg: $theme.red fg: $theme.base }{#

  in the following code, the closure inside the "list" path `|el|` has this color, as well as the surrounding curly braces
  def "str append" [tail: string]: [string -> string, list<string> -> list<string>] {
      let input = $in
      match ($input | describe | str replace --regex '<.*' '\') {
          "string" => { $input ++ $tail },
          "list" => { $input | each {|el| $el ++ $tail} },
          _ => $input
      }

  }#}
  shape_closure: $theme.teal
  shape_directory: $theme.blue
  shape_externalarg: $theme.text
  shape_filepath: $theme.blue
  shape_flag: $theme.yellow{#

  for instance, inputs to a command like `ls`. So `ls file1 *.txt`, both args are this

  #}
  shape_globpattern: $theme.text{#

  integers such as 1, 4, 15

  #}
  shape_int: $theme.peach{#

  command that is a binary, e.g. `ls`

  #}
  shape_internalcall: $theme.blue{#

  syntax for lists, for example in [1, 2, 3, 4, 5] the square brackets and the comma use this syntax

  #}
  shape_list: $theme.overlay2{#

  whatever is matching, for example we could be autocompleting on a filename
  the part of the filename which matches what we have is going to have this style

  #}
  shape_matching_brackets: { attr: u }{#

  example:
    null

  #}
  shape_nothing: $theme.peach{#

  example, the `|` in this command:
    echo "hello world" | cat

  #}
  shape_pipe: $theme.sky{#

  for example in { "apples": 543, "bananas": 411, "oranges": 0 }, the commas, curly braces and colons use this highlight

  #}
  shape_record: $theme.overlay2{#

  for example: 'hello world'

  #}
  shape_string: $theme.green{#

  symbols for the interpolated string, for example in $"greetings, ($name)" the following characters use this: $, first " and the last "

  also the highlight for the `B` in e.g. 100B, `wk` in 10wk and other literals

  #}
  shape_string_interpolation: $theme.flamingo{#

  for example: r#'hello world'

  #}
  shape_raw_string: $theme.green{#

  invalid syntax

  #}
  shape_garbage: $theme.red{#
  In the following code, `else` uses this highlight
  [black red yellow green purple blue] | each {|c|
    if ($c == "black") {
     "classy"
    } else if ($c in ["red", "green", "blue"]) {
      "fundamental"
    } else if ($c in ['yellow', "purple"]) {
      "vibrant"
    } else {
      "innovative"
    }
  }

  #}
  shape_keyword: $theme.mauve{#

  In the following code, the indentation uses this highlight
  as well as the first `if`, the parentheses around the condition, and the curly braces inside of each of the conditions
  [black red yellow green purple blue] | each {|c|
    if ($c == "black") {
     "classy"
    } else if ($c in ["red", "green", "blue"]) {
      "fundamental"
    } else if ($c in ['yellow', "purple"]) {
      "vibrant"
    } else {
      "innovative"
    }
  }

  #}
  shape_block: $theme.blue{#
  in the following code, all the possibilities are match items
  [black red yellow green purple blue indigo] | each {|c|
    match $c {
      "black" => "classy"
      "red" | "green" | "blue" => "fundamental"
      "yellow" | "purple" => "vibrant"
      _ => "innovative"
    }
  }
  #}
  shape_match_pattern: $theme.green{#
  In the following code, `in` and `==` use this highlight
  [black red yellow green purple blue] | each {|c|
    if ($c == "black") {
     "classy"
    } else if ($c in ["red", "green", "blue"]) {
      "fundamental"
    } else if ($c in ['yellow', "purple"]) {
      "vibrant"
    } else {
      "innovative"
    }
  }

  #}
  shape_operator: $theme.sky{#

  the highlights would apply to the semicolon, square backets and commans in the example:
	[[col1, col2]; [val1, val2] [val3 val4]]

  #}
  shape_table: $theme.overlay2{#

  a variable like $c for example

  #}
  shape_variable: { fg: $theme.peach attr: i }{#

  true and false

  #}
  shape_bool: $theme.peach{#

  in the following code, highlight is applied to [tail: string]: [string -> string, list<string> -> list<string>]

  def "str append" [tail: string]: [string -> string, list<string> -> list<string>] {
      let input = $in
      match ($input | describe | str replace --regex '<.*' '\') {
          "string" => { $input ++ $tail },
          "list" => { $input | each {|el| $el ++ $tail} },
          _ => $input
      }
  }

  #}
  shape_signature: $theme.teal{#

  in the following snippet, `fish_completer` declaration gets this highlight

  let fish_completer = {|spans|
      fish --command $'complete "--do-complete=($spans | str join " ")"'
      | from tsv --flexible --noheaders --no-infer
      | rename value description
  }

  #}
  shape_vardecl: { fg: $theme.peach attr: i }{#

  commands which are not a part of nushell, or maybe they're not command at all
  e.g. `l` is not a command, but it gets this color

  #}
  shape_external: $theme.blue{#

  a range like 1..5

  #}
  shape_range: $theme.sky{#

  in the following snippet, `out>` and `err>` are redirection
  cat unknown.txt out> out.log err> err.log

  #}
  shape_redirection: { fg: $theme.text attr: b }{#

  e.g. 1.41

  #}
  shape_float: $theme.peach{#

  for example
  0x[ffffff]
  0o[12374]
  0b[1010110101001]

  #}
  shape_binary: $theme.peach{#

  for example:
    2022-02-02
    2022-02-02T14:30:00+05:00

  #}
  shape_datetime: $theme.peach{#

  Below highlights are not used.

  For example, shape_custom exists but it cannot be declared by the user https://www.nushell.sh/lang-guide/chapters/types/other_types/01_not_declarable.html
  
  But we set it to high visibility colors so it's easy to spot if nushell releases an update where you can create them. Then we can find it and fix it in the themes
  #}
  shape_custom: { fg: "#ff0000" bg: "#ff0000" }
  glob: { fg: "#00ff00" bg: "#00ff00" }
  shape_external_resolved: { fg: "#0000ff" bg: "#0000ff" }
  shape_literal: { fg: "#ffff00" bg: "#ffff00" }
  shape_glob_interpolation: { fg: "#ff00ff" bg: "#ff00ff" }
  block: { fg: "#00ffff" bg: "#00ffff" }
}
